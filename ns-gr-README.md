# Tout
## Lister mes namespace K8S
```
sudo kubectl get namespaces
```
## Afficher mes li√©es au namespace ns-gr K8S
```
sudo kubectl get all -n ns-gr
sudo kubectl get secret,configmap -n ns-gr

```
## Cr√©ation de certificat gitlab self-signed √† un secret sous le namespace ns-gr K8S
### Existant
* Afficher les materiels cryptographiques de mon gitlab :
```sh
saber@optiplex3060:/etc/gitlab/ssl$ ll gitlab.*
-rw-r--r-- 1 root root  245 mars  22 16:38 gitlab.cnf
-rw-r--r-- 1 root root 1082 mars  22 16:44 gitlab.crt
-rw-r--r-- 1 root root  903 mars  22 16:43 gitlab.csr
-rw------- 1 root root 1708 mars  22 16:43 gitlab.key
saber@optiplex3060:/etc/gitlab/ssl$ cat gitlab.cnf
```
* Contenu de fichier gitlab.cnf :
```ini
[ req ]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[ req_distinguished_name ]
CN = gitlab.optiplex3060

[ v3_req ]
subjectAltName = @alt_names

[ alt_names ]
IP.1 = 192.168.1.76
DNS.1 = gitlab.optiplex3060

```
* Description de quelques √©l√©ments de fichier gitlab.cnf :

  * CN = gitlab.optiplex3060 ‚Üí Le nom commun (CN) du certificat est gitlab.optiplex3060.
  * subjectAltName (SAN) ‚Üí Cette section ajoute deux √©l√©ments :
      * IP.1 = 192.168.1.76
      * DNS.1 = gitlab.optiplex3060
### Cr√©ation et v√©rification
#### Cr√©ation de certificat num√©rique (self-signe)
Pour ajouter un certificat num√©rique, je propose deux fa√ßons de faire:
* Avec la creation d'un secret √† partir de certificat local:
```sh
sudo kubectl create secret generic gitlab-tls --from-file=gitlab.crt=/etc/gitlab/ssl/gitlab.crt -n ns-gr

```
* Avec la creation d'un ConfigMap  contenant le certificat TLS :
```yml 
apiVersion: v1
kind: ConfigMap
metadata:
  name: gitlab-ca-cert
  namespace: ns-gr  # Remplace avec le namespace appropri√©
data:
  gitlab.crt: |
    -----BEGIN CERTIFICATE-----
    MIIBItf1hsfts...
    -----END CERTIFICATE-----
  gitlab.key: |
    -----BEGIN PRIVATE KEY-----
    MIIEvAIBADANB...
    -----END PRIVATE KEY-----

```
‚ö†Ô∏è Inconv√©nient :
* La cl√© priv√©e ne devrait jamais √™tre stock√©e dans un ConfigMap, car les ConfigMaps ne sont pas chiffr√©s dans etcd (la base de donn√©es interne de Kubernetes).

* Toute personne avec acc√®s au ConfigMap peut voir la cl√© priv√©e, ce qui est un gros risque de s√©curit√© üö®.
* Si le certificat expire ou doit √™tre renouvel√©, il faut modifier le ConfigMap

#### V√©rification du certificat num√©rique (self-signe)
Voici une section qui explique √ßa en d√©tail : [Cr√©ation et v√©rification](Secrets/debug-test/debug-test.md)

## Cr√©er mon namespace ns-gr comme *namaspace gitlab-runner*
```
sudo kubectl create namespace ns-gr
```
## Cr√©ation du ServiceAccount, Role et RoleBinding pour GitLab Runner
Cr√©er un ServiceAccount, un Role et un RoleBinding dans le namespace ns-gr pour attribuer des permissions au GitLab Runner.
  * Pour √ßa, j'utilise les fichiers manifest suivant :
    1. [ServiceAccount](ServiceAccountRBAC/a_service-account.yaml) 
    2. [Role ](ServiceAccountRBAC/b_role.yaml) 
    3. [Rolebiding](ServiceAccountRBAC/c_role-biding.yaml) 
    ```bash
    sudo kubectl apply -f serviceAccount_Role_RoleBiding_RBAC.yaml
    sudo kubectl apply -f serviceAccount_Role_RoleBiding_RBAC.yaml
    sudo kubectl apply -f serviceAccount_Role_RoleBiding_RBAC.yaml
    ```

  * Ou bien, utiliser le fichier cobin√© qui contient les diff√®rent manifests pr√©c√©dents:
    * [le fichier combin√© ](ServiceAccountRBAC/ serviceAccount_Role_RoleBiding_RBAC.yaml)

    ```bash
    sudo kubectl apply -f serviceAccount_Role_RoleBiding_RBAC.yaml
    ```
![Description de l'image](assets/image1.png)
